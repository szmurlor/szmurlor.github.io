<!DOCTYPE html>
<html>
  <head>
    <title>Python Programming and Data Visualisation</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../../Includes/remark-rs.css" />
  </head>
  <body>
    <textarea id="source">

class: center, middle, inverse

# Python programming and data visualisation
## Lecture 4
## Robert Szmurło
e-mail: robert.szmurlo@ee.pw.edu.pl
2018Z

---

# Lecture outline

1. Introduction to NumPy
2. Intorduction to matplotlib
3. Example visualisation analysis

Next lecture

* Introduction to statistical data visualisation

---

# Lecture 3 - quick review

* basic exception handling
* closures in Python
* context managers - way to automatically handle aquire / release rsources
* decorators - elegant extention of functionality to functions and classes

---
## What is NumPy

.ref[https://en.wikipedia.org/wiki/NumPy]

.img-top-right[
![NumPy logo](img/numpy-logo.png)
NumPy is a library for the Python programming language, adding support for large,
multi-dimensional arrays and matrices, along with a large collection of
high-level mathematical functions to operate on these arrays.

The ancestor of NumPy, Numeric, was originally created by Jim Hugunin with
contributions from several other developers. In 2005, Travis Oliphant
created NumPy by incorporating features of the competing Numarray into Numeric,
with extensive modifications.

NumPy targets the CPython reference implementation of Python, which is a
non-optimizing bytecode interpreter. Mathematical algorithms written for this
version of Python often run much slower than compiled equivalents.
NumPy addresses the slowness problem partly by providing multidimensional
arrays and functions and operators that operate efficiently on arrays,
requiring rewriting some code, mostly inner loops using NumPy.
]

---

## Let we test NumPy

To quickly test its power lew we test simple loops in Python. Let we assume that
we want to calculate an average value of uniformly distributed random numbers
within the range 0 to 10. If the unmber of values is large anugh the average
number in this set should be close to 5.0.

To do it naivly in Python we can:
```python
import numpy as np
import random
s = 0
n = 10000
for i in range(10000):
  s = s + random.uniform(0,10)
a = s/n
a
```

The `%%timeit` in colab gives us:
```
100 loops, best of 3: 3.88 ms per loop
```
--
.red[**Warning!**] This test is very poor! We actually evaluate the random function
and not the looping.
---
## Let we improve the test - generate vector first

We generate a vector of values in advance.
```python
v = [random.uniform(0,10) for i in range(n)]
```
and then test it
```python
%%timeit
s=0
for i in range(10000):
  s = s + v[i]
a = s/n
a
```
The result is 4 times sorter:
```
1000 loops, best of 3: 888 µs per loop
```

---
## Ok - let we check numpy

Let we convert a Python array (list) into Python ndarray
```python
vn = np.array(v)
```
and then test it
```python
%%timeit
s=0
for i in range(10000):
  s = s + vn[i]
a = s/n
a
```
The result is... 2 times WORSE than Python:
```
1000 loops, best of 3: 1.93 ms per loop
```

**WTH?**

--
The answer is an additional cost related to python-numpy interface.

---

## OK - final test - built in functions

Let we use a built in function `np.sum()` which is entirely written in C.

```python
%%timeit
s = np.sum(vn)
a = s/n
a
```
The result is impressive:
```
The slowest run took 13.57 times longer than the fastest. This could mean that an intermediate result is being cached.
100000 loops, best of 3: 6.96 µs per loop
```

--

Ok, but in Python we have a built-in function `sum()`.

```python
%%timeit
s = sum(v)
a = s/n
a
```
The time length test result is ok, but still 10 times slower than that of NumPy.
```
10000 loops, best of 3: 74.2 µs per loop
```

---

## The ndarray data structure

The core functionality of NumPy is its "ndarray", for n-dimensional array,
data structure. These arrays are strided views on memory. In contrast to
Python's built-in list data structure (which, despite the name, is a
dynamic array), these arrays are homogeneously typed: all elements of a
single array must be of the same type

NumPy has built-in support for memory-mapped ndarrays.

.left-column[
```python
>> a = np.array([1,2,3])
>> type(a)

numpy.ndarray

>> a.nbytes
24
```
]

.right-column[
```python
A = np.arange(9).reshape(3,3)
print(A)
b = np.arange(3)

print(A)
print(b)

print(f'A * b = {A.dot(b)}')
print(f'A * b = {A @ b}')
```
]

.clear[
]

Inserting or appending entries to an array is not as trivially possible as it
is with Python's lists. The np.pad(...) routine to extend arrays actually
creates new arrays of the desired shape and padding values, copies the given
array into the new one and returns it. NumPy's np.concatenate([a1,a2]) operation
does not actually link the two arrays but returns a new one, filled with
the entries from both given arrays in sequence.

---

## Operations using Numpy

.img-top-right[
![Fast](img/fast.png)
]

Fast vectorized array operations for data munging and cleaning, subsetting and
filtering, transformation, and any other kinds of computations

 * Common array algorithms like sorting, unique, and set operations
 * Efficient descriptive statistics and aggregating/summarizing data
 * Data alignment and relational data manipulations for merging and
   joining together heterogeneous data sets
 * Expressing conditional logic as array expressions instead of loops with
   if-elifelse branches
 * Group-wise data manipulations (aggregation, transformation, function

---
## Let we compare NumPy to Octave/MATLAB

.left-column[
Vector creation in MATLAB:
```MATLAB
>> x = [1; 3; 2];
>> y = [1, 3, 2];
>> A = [1, 1, 2; 3, 5, 8; 13, 21, 34];
```

other simple operations:
```MATLAB
a = [1,2,3];
a.*2
a.^2
a*a'
```
get size (shape) of a matrix:

```
>> [r,c] = size(a)
r =
     1
c =
     3
```
]

.right-column[
Vector creation in NumPy:
```python
import numpy as np
np.matrix('1 2; 3 4')
matrix([[1, 2],
        [3, 4]])
```
or we can

```python
A = np.array([1,2,3,4]).reshape(2,2)
A = (np.array([1, 1, 2, 3, 5, 8, 13, 21, 34])
      .reshape(3,3))
A = np.arange(0, 9, 2)
v = np.linspace(0, 9, 10)
r = np.random.rand(2)
```

other simple operations:
```python
a = np.array([1,2,3])
print(f'Multiply each element by a scalar: {a*2}')
print(f'Square each element: {a**2}')
print(f'Calculate dot product: {a*a.T}')
```

get shape of a matrix or array:
```Python
a.shape
A.shape
```
]


---

## Numpy Broadcasting

Numpy arrays differ from a normal Python list because of their ability to broadcast:

```python
#Setting a value with index range (Broadcasting)
arr[0:5]=100
```


By default all vectors are assumed to be one dimensional.
We can turn a vector into a 2D matrix by adding a row  dimension to it:

```python
>>> y = y[None,:]
array([[1, 3, 2]])

>>> y.shape
(1, 3)
```

Vectors (vertical vectors) can be created in a similar way, but the added dimension should be the column dimension this time

```
>>> x = np.array([1,3,2])[:,None]
>>> x
array([[1],
       [3],
       [2]])
>>> x.shape
(3, 1)
```

---

## Matrix slicing

```python
import numpy as np

A = np.array([[1, 4, 5, 12, 14],
    [-5, 8, 9, 0, 17],
    [-6, 7, 11, 19, 21]])

print(A[:2, :4])  # two rows, four columns

''' Output:
[[ 1  4  5 12]
 [-5  8  9  0]]
'''


print(A[:1,])  # first row, all columns

''' Output:
[[ 1  4  5 12 14]]
'''

print(A[:,2])  # all rows, second column

''' Output:
[ 5  9 11]
'''

print(A[:, 2:5])  # all rows, third to fifth column

'''Output:
[[ 5 12 14]
 [ 9  0 17]
 [11 19 21]]
'''
```
---

## Important notes on Slices

Slices are not copies but references to original ndarrays.

Example:
```python
a = np.arange(10)
print(a)
a_slice = a[0:3]
print(a_slice)
a_slice[:] = 99
print(a_slice)
print(a)
```

Output:
```
[0 1 2 3 4 5 6 7 8 9]
[0 1 2]
[99 99 99]
[99 99 99  3  4  5  6  7  8  9]
```

Note the changes also occur in our original array!
Data is not copied, it's a view of the original array! This avoids memory problems!
---

## Selection

Let's briefly go over how to use brackets for selection based off of comparison operators.

```python
arr = np.arange(1,11)
print(arr)
print(arr > 4)
bool_arr = arr>4
print(bool_arr)
print(arr[bool_arr])
arr[bool_arr] = 4
print(arr)
arr[ arr < 3 ] = 3
print(arr)
```

Output:
```
[ 1  2  3  4  5  6  7  8  9 10]
[False False False False  True  True  True  True  True  True]
[False False False False  True  True  True  True  True  True]
[ 5  6  7  8  9 10]
[1 2 3 4 4 4 4 4 4 4]
[3 3 3 4 4 4 4 4 4 4]
```
---

## Searching min/max

The functions: `min`, `max`, `argmax`, `argmin`

```Python
np.random.seed(10)
A = np.random.rand(5,5)
print(A)
print(f'\nGlobal maximum value = {np.max(A)}')
print(f'Maximum values in columns = {np.max(A, axis=0)}')
print(f'Maximum valus in rows = {np.max(A, axis=1)}')
print(f'Global maximum value index = {np.argmax(A)}')
print(f'Maximum values in columns index = {np.argmax(A, axis=0)}')
print(f'Maximum valus in rows index = {np.argmax(A, axis=1)}')
```

Output:
```Python
[[0.77132064 0.02075195 0.63364823 0.74880388 0.49850701]
 [0.22479665 0.19806286 0.76053071 0.16911084 0.08833981]
 [0.68535982 0.95339335 0.00394827 0.51219226 0.81262096]
 [0.61252607 0.72175532 0.29187607 0.91777412 0.71457578]
 [0.54254437 0.14217005 0.37334076 0.67413362 0.44183317]]

Global maximum value = 0.9533933461949365
Maximum values in columns = [0.77132064 0.95339335 0.76053071 0.91777412 0.81262096]
Maximum valus in rows = [0.77132064 0.76053071 0.95339335 0.91777412 0.67413362]
Global maximum value index = 11
Maximum values in columns index = [0 2 1 3 2]
Maximum valus in rows index = [0 2 1 3 3]
```
---
## Universal array functions

Numpy comes with many universal array functions, which are essentially
just mathematical operations you can use to perform the operation across
the array. Let's show some common ones:

```python
#Taking Square Roots
>> np.sqrt(arr)

array([ 0.        ,  1.        ,  1.41421356,  1.73205081,  2.        ,
        2.23606798,  2.44948974,  2.64575131,  2.82842712,  3.        ])
```

```python
#Calcualting exponential (e^)
>> np.exp(arr)

array([  1.00000000e+00,   2.71828183e+00,   7.38905610e+00,
         2.00855369e+01,   5.45981500e+01,   1.48413159e+02,
         4.03428793e+02,   1.09663316e+03,   2.98095799e+03,
         8.10308393e+03])
```

```python
>> np.sin(arr)

array([ 0.        ,  0.84147098,  0.90929743,  0.14112001, -0.7568025 ,
       -0.95892427, -0.2794155 ,  0.6569866 ,  0.98935825,  0.41211849])
```

```python
>> np.log(arr)

/Users/szmurlor/anaconda/lib/python3.5/site-packages/ipykernel/__main__.py:1: RuntimeWarning: divide by zero encountered in log
  if __name__ == '__main__':
array([       -inf,  0.        ,  0.69314718,  1.09861229,  1.38629436,
        1.60943791,  1.79175947,  1.94591015,  2.07944154,  2.19722458])
```

---

## When NumPy is faster

.ref[https://medium.com/coding-with-clarity/speeding-up-python-and-numpy-c-ing-the-way-3b9658ed78f4]

Let we consider a highly iterative algorithm in Python. The algorithm is a major performance
 bottleneck in our code so naturally we want to see if there were easy ways to speed it up.

```python
def mean(lst):
    return sum(lst) / len(lst)


def standard_deviation(lst):
    m = mean(lst)
    variance = sum([(value - m) ** 2 for value in lst])
    return math.sqrt(variance / len(lst))
```

we can happily replace this within

```Python
np.std(lst)
```

---

## Let we test it

Prepare test data:

```python
import random
random.seed(1)
n = 25
v = [random.uniform(0.0,10.0) for i in range(n)]
```

.left-column[
Do it with pure Python:
```Python
%%timeit
for i in range(1000):
  standard_deviation(v)
```

Result:
```
100 loops, best of 3: 4.27 ms per loop
```
]

.right-column[
Do it with NumPy:
```python
%%timeit
for i in range(1000):
  np.std(vn)
```

Result:
```
100 loops, best of 3: 19.6 ms per loop
```
]

---
## When it is faster?

.smaller[
The key comes in the data set this algorithm used. We calculated the standard
deviation of very small chunks of data at a time, 25 elements.

NumPy is only optimized for larger arrays. So in this case we’re below that
threshold and slow, interpreted Python actually beats NumPy.

So at what array size does NumPy start to beat a Python implementation?
]

.img-center[
![Comparison of NumPy and native Python iterators](img/numpy-python.png)
]

---
## Speeding it up with C++


---

## The Game of Life

.ref[http://www.labri.fr/perso/nrougier/teaching/numpy/numpy.html]

Numpy is slanted toward scientific computing and we'll consider in this
section the game of life by John Conway which is one of the earliest example
of cellular automata (see figure below).

.img-center[
![Simulation of the game of life.](img/game-of-life.png)
.left[**Figure 1** Simulation of the game of life.]
]

---

## Matplotlib tutorial

.ref{http://www.labri.fr/perso/nrougier/teaching/matplotlib/matplotlib.html}

```Python
# -----------------------------------------------------------------------------
# Copyright (c) 2015, Nicolas P. Rougier. All Rights Reserved.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.
# -----------------------------------------------------------------------------
import numpy as np
import matplotlib.pyplot as plt

eqs = []
eqs.append((r"$W^{3\beta}_{\delta_1 \rho_1 \sigma_2} = U^{3\beta}_{\delta_1 \rho_1} + \frac{1}{8 \pi 2} \int^{\alpha_2}_{\alpha_2} d \alpha^\prime_2 \left[\frac{ U^{2\beta}_{\delta_1 \rho_1} - \alpha^\prime_2U^{1\beta}_{\rho_1 \sigma_2} }{U^{0\beta}_{\rho_1 \sigma_2}}\right]$"))
eqs.append((r"$\frac{d\rho}{d t} + \rho \vec{v}\cdot\nabla\vec{v} = -\nabla p + \mu\nabla^2 \vec{v} + \rho \vec{g}$"))
eqs.append((r"$\int_{-\infty}^\infty e^{-x^2}dx=\sqrt{\pi}$"))
eqs.append((r"$E = mc^2 = \sqrt{{m_0}^2c^4 + p^2c^2}$"))
eqs.append((r"$F_G = G\frac{m_1m_2}{r^2}$"))


plt.axes([0.025,0.025,0.95,0.95])

for i in range(24):
    index = np.random.randint(0,len(eqs))
    eq = eqs[index]
    size = np.random.uniform(12,32)
    x,y = np.random.uniform(0,1,2)
    alpha = np.random.uniform(0.25,.75)
    plt.text(x, y, eq, ha='center', va='center', color="#11557c", alpha=alpha,
             transform=plt.gca().transAxes, fontsize=size, clip_on=True)

plt.xticks([]), plt.yticks([])
# savefig('../figures/text_ex.png',dpi=48)
plt.show()
```
---

## Matplotlib Overview

.smaller[

Matplotlib is the "grandfather" library of data visualization with Python.
It was created by John Hunter. He created it to try to replicate MatLab's
(another programming language) plotting capabilities in Python. So if you
happen to be familiar with matlab, matplotlib will feel natural to you.

It is an excellent 2D and 3D graphics library for generating scientific figures.

Some of the major Pros of Matplotlib are:

* Generally easy to get started for simple plots
* Support for custom labels and texts
* Great control of every element in a figure
* High-quality output in many formats
* Very customizable in general

Matplotlib allows you to create reproducible figures programmatically. Let's learn how to use it! Before continuing this lecture, I encourage you just to explore the official Matplotlib web page: http://matplotlib.org/

## Installation

You'll need to install matplotlib first with either:

    conda install matplotlib
or
    pip install matplotlib

]

---

## Matplotlib basic example

We can create a very simple line plot using the following
( I encourage you to pause and use Shift+Tab along the way to check
out the document strings for the functions we are using).

```python
import numpy as np
x = np.linspace(0, 5, 11)
y = x ** 2
plt.plot(x, y, 'r') # 'r' is the color red
plt.xlabel('X Axis Title Here')
plt.ylabel('Y Axis Title Here')
plt.title('String Title Here')
plt.show()
```
.img-center-smaller[
![x^2](img/matplotlib-1.png)
]

---

## Creating Multiplots on Same Canvas

.left-column[
```python
# plt.subplot(nrows, ncols, plot_number)
plt.subplot(1,2,1)
plt.plot(x, y, 'r--') # More on color options later
plt.subplot(1,2,2)
plt.plot(y, x, 'g*-');
```
]

.right-column[
.img-center[
![x^2](img/matplotlib-2.png)
]
]
---
## Matplotlib Object Oriented Method

.img-bottom-right[

![x^2](img/matplotlib-2.png)

Matplotlib's Object Oriented API. This means we will instantiate figure objects
and then call methods or attributes from that object.

The main idea in using the more formal Object Oriented method is to create
figure objects and then just call methods or attributes off of that object.
This approach is nicer when dealing with a canvas that has multiple plots on it.

To begin we create a figure instance. Then we can add axes to that figure:

```python
# Create Figure (empty canvas)
fig = plt.figure()

# Add set of axes to figure
axes = fig.add_axes([0.1, 0.1, 0.8, 0.8]) # left, bottom, width, height (range 0 to 1)

# Plot on that set of axes
axes.plot(x, y, 'b')
axes.set_xlabel('Set X Label') # Notice the use of set_ to begin methods
axes.set_ylabel('Set y Label')
axes.set_title('Set Title')
```
]

---

## Multiple plots canvas

Code is a little more complicated, but the advantage is that we now have full
control of where the plot axes are placed, and we can easily add more than one axis to the figure:

.left-column[

```python
# Creates blank canvas
fig = plt.figure()

axes1 = fig.add_axes([0.1, 0.1, 0.8, 0.8]) # main axes
axes2 = fig.add_axes([0.2, 0.5, 0.4, 0.3]) # inset axes

# Larger Figure Axes 1
axes1.plot(x, y, 'b')
axes1.set_xlabel('X_label_axes2')
axes1.set_ylabel('Y_label_axes2')
axes1.set_title('Axes 2 Title')

# Insert Figure Axes 2
axes2.plot(y, x, 'r')
axes2.set_xlabel('X_label_axes2')
axes2.set_ylabel('Y_label_axes2')
axes2.set_title('Axes 2 Title');
```

]

.right-column[
.img-center-full[
  ![Plot on canvas](img/matplotlib-4.png)
  ]
]

---
## subplots()

You can specify the number of rows and columns when creating the subplots() object,
and you can iterate through array of axes:

.left-column[
```python
import numpy as np
x = np.linspace(0, 5, 100)
y = np.sin(1/x)
fig, axes = plt.subplots(nrows=1, ncols=2)
for ax in axes:
    ax.plot(x, y, 'b')
    ax.set_xlabel('x')
    ax.set_ylabel('y(x)=sin(x)')
    ax.set_title('$sin(x)$')

# Display the figure object
# fig
```
.small[
A common issue with matplolib is overlapping subplots or figures.
We ca use fig.tight_layout() or plt.tight_layout() method, which
automatically adjusts the positions of the axes on the figure canvas
so that there is no overlapping content:
]

```
...
plt.tight_layout()
```
]

.right-column[
.img-center-full[
  ![Plot on canvas](img/matplotlib-5.png)
  ]


.img-center-full[
  ![Plot on canvas](img/matplotlib-6.png)
  ]
]

---

## Figure size, aspect ratio and DPI

.smaller[
Matplotlib allows the aspect ratio, DPI and figure size to be specified when
the Figure object is created. You can use the `figsize` and `dpi` keyword arguments.
* `figsize` is a tuple of the width and height of the figure in inches
* `dpi` is the dots-per-inch (pixel per inch).

For example:

```python
fig = plt.figure(figsize=(8,4), dpi=100)
```

The same arguments can also be passed to layout managers, such as the `subplots` function:

```python
fig, axes = plt.subplots(figsize=(12,3))

axes.plot(x, y, 'r')
axes.set_xlabel('x')
axes.set_ylabel('y')
axes.set_title('title');
```
]

.img-center[
  ![Plot on canvas 7](img/matplotlib-7.png)
  ]

---
## Saving figures

.small[

* Matplotlib can generate high-quality output in a number formats, including PNG,
JPG, EPS, SVG, PGF and PDF.
* We can also optionally specify the DPI and choose between different output formats

```python
fig.savefig("filename.png", dpi=200)
```

### Legends, labels and titles

.img-bottom-right[
  ![Plot on canvas 8](img/matplotlib-8.png)
  ]

Decorate a figure with titles, axis labels, and legends.

* with the methods `set_xlabel` and `set_ylabel`, we can set the labels of the X and Y axes:
```python
ax.set_xlabel("x")
ax.set_ylabel("y");
```
* use the **label="label text"** keyword argument when plots or other objects
are added to the figure, and then using the **legend** method without
arguments to add the legend to the figure:
```python
fig = plt.figure(figsize=(3,2))
ax = fig.add_axes([0,0,1,1])
ax.plot(x, x**2, label="$x^2$")
ax.plot(x, x**3, label="$x^3$")
ax.legend()
ax.legend(loc=1) # upper right corner
ax.legend(loc=2) # upper left corner
ax.legend(loc=3) # lower left corner
ax.legend(loc=4) # lower right corner
ax.legend(loc=0) # let matplotlib decide the optimal location
```
]

---
## Setting colors, linewidths, linetypes

.small[
.img-top-right[
  ![Plot on canvas 9](img/matplotlib-9.png)
  ]

* Matplotlib gives you *a lot* of options for customizing colors, linewidths,
and linetypes.
* There is the basic MATLAB like syntax (which I would suggest you avoid using
for more clairty sake:

```python
fig, ax = plt.subplots(figsize=(5,4))
ax.plot(x, x**2, 'bd-') # blue line with diamonds
ax.plot(x, x**3, 'g--') # green dashed line
ax.plot(x, x**4*np.exp(-x), 'mo-') # magenta line with circles
```

* Define colors by their names or RGB hex codes and optionally provide an
alpha value using the `color` and `alpha` keyword arguments. Alpha indicates opacity.

```python
fig, ax = plt.subplots()
ax.plot(x, x+1, color="blue", alpha=0.5) # half-transparant
ax.plot(x, x+2, color="#8B008B")        # RGB hex code
ax.plot(x, x+3, color="#FF8C00")        # RGB hex code
```
]
---
## Line and marker styles

.small[
To change the line width, we can use the `linewidth` or `lw` keyword argument.
The line style can be selected using the `linestyle` or `ls` keyword arguments:
]

```python
fig, ax = plt.subplots(figsize=(12,6))
ax.plot(x, x+1, color="red", linewidth=0.25)
ax.plot(x, x+2, color="red", linewidth=0.50)
ax.plot(x, x+3, color="red", linewidth=1.00)
ax.plot(x, x+4, color="red", linewidth=2.00)
ax.plot(x, x+5, color="green", lw=3, linestyle='-')
ax.plot(x, x+6, color="green", lw=3, ls='-.')
ax.plot(x, x+7, color="green", lw=3, ls=':')
line, = ax.plot(x, x+8, color="black", lw=1.50)
line.set_dashes([5, 10, 15, 10]) # format: line length, space length, ...
ax.plot(x, x+ 9, color="blue", lw=3, ls='-', marker='+')
ax.plot(x, x+10, color="blue", lw=3, ls='--', marker='o')
ax.plot(x, x+11, color="blue", lw=3, ls='-', marker='s')
ax.plot(x, x+12, color="blue", lw=3, ls='--', marker='1')
ax.plot(x, x+13, color="purple", lw=1, ls='-', marker='o', markersize=2)
ax.plot(x, x+14, color="purple", lw=1, ls='-', marker='o', markersize=4)
ax.plot(x, x+15, color="purple", lw=1, ls='-', marker='o', markersize=8, markerfacecolor="red")
ax.plot(x, x+16, color="purple", lw=1, ls='-', marker='s', markersize=8,
        markerfacecolor="yellow", markeredgewidth=3, markeredgecolor="green");
```

---
## Line and marker styles

.small[
To change the line width, we can use the `linewidth` or `lw` keyword argument.
The line style can be selected using the `linestyle` or `ls` keyword arguments:
]

```python
fig, ax = plt.subplots(figsize=(12,6))
ax.plot(x, x+1, color="red", linewidth=0.25)
ax.plot(x, x+2, color="red", linewidth=0.50)
ax.plot(x, x+3, color="red", linewidth=1.00)
ax.plot(x, x+4, color="red", linewidth=2.00)
ax.plot(x, x+5, color="green", lw=3, linestyle='-')
ax.plot(x, x+6, color="green", lw=3, ls='-.')
ax.plot(x, x+7, color="green", lw=3, ls=':')
line, = ax.plot(x, x+8, color="black", lw=1.50)
line.set_dashes([5, 10, 15, 10]) # format: line length, space length, ...
ax.plot(x, x+ 9, color="blue", lw=3, ls='-', marker='+')
ax.plot(x, x+10, color="blue", lw=3, ls='--', marker='o')
ax.plot(x, x+11, color="blue", lw=3, ls='-', marker='s')
ax.plot(x, x+12, color="blue", lw=3, ls='--', marker='1')
ax.plot(x, x+13, color="purple", lw=1, ls='-', marker='o', markersize=2)
ax.plot(x, x+14, color="purple", lw=1, ls='-', marker='o', markersize=4)
ax.plot(x, x+15, color="purple", lw=1, ls='-', marker='o', markersize=8, markerfacecolor="red")
ax.plot(x, x+16, color="purple", lw=1, ls='-', marker='s', markersize=8,
        markerfacecolor="yellow", markeredgewidth=3, markeredgecolor="green");
```

.img-center-over[
![Matplotlib 13](img/matplotlib-13.png)
]

---
## Plot range

.img-top-right[
![Matplotlib 10](img/matplotlib-10.png)
]
We can configure the ranges of the axes using the `set_ylim` and `set_xlim`
methods in the axis object, or `axis('tight')` for automatically getting
"tightly fitted" axes ranges:

```python
fig, axes = plt.subplots(1, 2, figsize=(6, 3))

axes[0].plot(x, x**2, x, x**3)
axes[0].set_title("default axes ranges")

axes[1].plot(x, x**2, x, x**3)
axes[1].set_ylim([0, 60])
axes[1].set_xlim([2, 5])
axes[1].set_title("custom axes range");
```
---

## Special Plot Types

* Specialized plots: barplots, histograms, scatter plots, and much more.
  Most of these typeof plots by data scientists is actually created using seaborn,
  a statistical plotting library for Python. But here are a few examples
  of these type of plots.

.left-column[
```python
import matplotlib
fig = plt.figure(figsize=(6,3))
ax = fig.add_axes([0, 0, 1, 1])
ms = matplotlib.markers.MarkerStyle()
ax.scatter(x,y, color='#FF0000', marker='+', s=200)
```

```python
from random import sample
data = sample(range(1, 1000), 100)
fig = plt.figure(figsize=(6,3))
ax = fig.add_axes([0,0,1,1])
ax.hist(data, rwidth=0.9)```

]

.right-column[
.img-center-full[
![Matplotlib 11](img/matplotlib-11.png)
]
.img-center-full[
![Matplotlib 12](img/matplotlib-12.png)
]

]
---
## Logarithmic scale

.small[
It is also possible to set a logarithmic scale for one or both axes.
This functionality is in fact only one application of a more general
transformation system in Matplotlib. Each of the axes' scales are set
seperately using `set_xscale` and `set_yscale` methods which accept one
parameter (with the value "log" in this case):
]

```python
import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(0, 5, 11)
y = x ** 2
fig, axes = plt.subplots(1, 2, figsize=(8,3))
axes[0].plot(x, x**2, x, np.exp(x))
axes[0].set_title("Normal scale")
axes[1].plot(x, x**2, x, np.exp(x))
axes[1].set_yscale("log")
axes[1].set_title("Logarithmic scale (y)");
```
.img-center[
![Matplotlib 14](img/matplotlib-14.png)
]
---
## Placement of ticks and custom tick labels, axis grid

.small[
* We can explicitly determine where we want the axis ticks with `set_xticks`
and `set_yticks`, which both take a list of values for where on the axis the
ticks are to be placed. We can also use the `set_xticklabels` and
`set_yticklabels` methods to provide a list of custom text labels for each tick location:
* With the `grid` method in the axis object, we can turn on and off grid lines.
We can also customize the appearance of the grid lines using the same keyword arguments as the `plot` function:

```python
fig, axes = plt.subplots(1, 2, figsize=(10,3))
# default grid appearance
axes[0].plot(x, x**2, x, x**3, lw=2)
axes[0].grid(True)
axes[0].set_yticks([0, 50, 60, 70, 80, 90, 100, 150])
# custom grid appearance
axes[1].plot(x, x**2, x, x**3, lw=8)
axes[1].grid(color='b', alpha=0.5, linestyle='dashed', linewidth=1.5)
```
]

.img-center-full[
![Matplotlib 15](img/matplotlib-15.png)
]
---
## Coutour plots with projections

```python
fig = plt.figure(figsize=(8,6))
ax = fig.add_subplot(1,1,1, projection='3d')
ax.plot_surface(X, Y, Z, rstride=4, cstride=4, alpha=0.25)
cset = ax.contour(X, Y, Z, zdir='z', offset=-np.pi, cmap=matplotlib.cm.coolwarm)
cset = ax.contour(X, Y, Z, zdir='x', offset=-np.pi, cmap=matplotlib.cm.coolwarm)
cset = ax.contour(X, Y, Z, zdir='y', offset=3*np.pi, cmap=matplotlib.cm.jet,
                 levels=(-2,-1,-0.75, -0.5,0,0.5,1,1.5,2,3,4,5))
ax.set_xlim3d(-np.pi, 2*np.pi);
ax.set_ylim3d(0, 3*np.pi);
ax.set_zlim3d(-np.pi, 2*np.pi);
```

.img-center-small[
![Matplotlib 16](img/matplotlib-16.png)
.left[.small[**Fig.1.** Coutour plots with projections]]
]
---

## Matplotlib - Further reading

* http://www.matplotlib.org - The project web page for matplotlib.
* https://github.com/matplotlib/matplotlib - The source code for matplotlib.
* http://matplotlib.org/gallery.html - A large gallery showcaseing various types of plots matplotlib can create. Highly recommended!
* http://www.loria.fr/~rougier/teaching/matplotlib - A good matplotlib tutorial.
* http://scipy-lectures.github.io/matplotlib/matplotlib.html - Another good matplotlib reference.

---

## Numpy Exercises

.ref[http://www.labri.fr/perso/nrougier/teaching/numpy-100.html]
---

.center[
# Thank you]

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML&delayStartupUntil=configured" type="text/javascript"></script>
    <script>
      var slideshow = remark.create();
      // Setup MathJax
     MathJax.Hub.Config({
         tex2jax: {
         skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
         }
     });
     MathJax.Hub.Queue(function() {
         $(MathJax.Hub.getAllJax()).map(function(index, elem) {
             return(elem.SourceElement());
         }).parent().addClass('has-jax');
     });

     MathJax.Hub.Configured();
    </script>
  </body>
</html>
